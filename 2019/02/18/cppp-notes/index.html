<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="coding,cpp," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="迭代器取中间值mid = beg + (end-beg)/2;而不是mid = (beg + end)/2;  没有两个迭代器相加的operator 可能overflow  数组复杂的数组声明int (*Parray)[10] 首先是指针，然后是10个数组，数组里是整数。是一个指向一个包含十个int的数组的指针。int *(&amp;amp;array)[10] 首先是个引用，10个数组，是整数指针，所以">
<meta name="keywords" content="coding,cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp primer notes">
<meta property="og:url" content="http://www.mengfansong.me/2019/02/18/cppp-notes/index.html">
<meta property="og:site_name" content="松鹅的博客">
<meta property="og:description" content="迭代器取中间值mid = beg + (end-beg)/2;而不是mid = (beg + end)/2;  没有两个迭代器相加的operator 可能overflow  数组复杂的数组声明int (*Parray)[10] 首先是指针，然后是10个数组，数组里是整数。是一个指向一个包含十个int的数组的指针。int *(&amp;amp;array)[10] 首先是个引用，10个数组，是整数指针，所以">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-06-18T15:00:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp primer notes">
<meta name="twitter:description" content="迭代器取中间值mid = beg + (end-beg)/2;而不是mid = (beg + end)/2;  没有两个迭代器相加的operator 可能overflow  数组复杂的数组声明int (*Parray)[10] 首先是指针，然后是10个数组，数组里是整数。是一个指向一个包含十个int的数组的指针。int *(&amp;amp;array)[10] 首先是个引用，10个数组，是整数指针，所以">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mengfansong.me/2019/02/18/cppp-notes/"/>





  <title>cpp primer notes | 松鹅的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">松鹅的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mengfansong.me/2019/02/18/cppp-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="松鹅">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="松鹅的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cpp primer notes</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T20:10:02+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="取中间值"><a href="#取中间值" class="headerlink" title="取中间值"></a>取中间值</h4><p><code>mid = beg + (end-beg)/2;</code>而不是<code>mid = (beg + end)/2;</code></p>
<ol>
<li>没有两个迭代器相加的operator</li>
<li>可能overflow</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p><code>int (*Parray)[10]</code> 首先是指针，然后是10个数组，数组里是整数。是一个指向一个包含十个int的数组的指针。<br><code>int *(&amp;array)[10]</code> 首先是个引用，10个数组，是整数指针，所以是一个有10个整数指针数组的引用。</p>
<h4 id="begin函数"><a href="#begin函数" class="headerlink" title="begin函数"></a>begin函数</h4><p>C++11中可以使用<code>begin()</code>和<code>end()</code>来获得。在<code>iterator</code>头文件中。</p>
<p><em>指针也是迭代器</em></p>
<h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><p>如果是数组，比较的是指针。<code>string</code>比较的是值。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p><code>inline</code></p>
<p>将它在每个调用点上“内联地”展开，可以消除函数运行时的开销。</p>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><code>bool (*pf) (const string &amp;)</code></p>
<p>注意，函数指针的括号不可以升略。</p>
<h4 id="debug技巧"><a href="#debug技巧" class="headerlink" title="debug技巧"></a>debug技巧</h4><p><code>__func__</code>存放当前调试的函数名</p>
<p><code>__FILE__</code>存放文件名的字符串字面值</p>
<p><code>__LINE__</code>存放当前行号的字面值</p>
<p><code>__TIME__</code>存放文件编译时间</p>
<p><code>__DATE__</code>存放编译的日期</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的基本思想是<strong>数据抽象（data abstraction）</strong>和<strong>封装（encapsulation）</strong>。</p>
<p>数据抽象是一种依赖于<strong>接口（interface）</strong>和<strong>实现（implementation）</strong>分离的编程技术。</p>
<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a><code>const</code>成员函数</h4><p><strong>常量成员函数（const member function）</strong></p>
<p>允许把<code>const</code>关键字放在成员函数的参数列表之后，紧跟在参数列表后面的<code>const</code>表示<code>this</code>是一个指向常量的指针。这样使用<code>const</code>的成员函数被称为常量成员函数。</p>
<p><strong>编译器处理类</strong>：</p>
<ol>
<li>编译成员的声明</li>
<li>成员函数体</li>
</ol>
<p>所以无需在意类中的其他成员的出现顺序。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>名字和类名一样，没有返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    Sales_data() = <span class="keyword">default</span>; <span class="comment">// C++11标准，可以写上default要求编译器生成构造器。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>构造函数初始值列表（constructor initialize list）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s) : bookNo(s) &#123; &#125;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s) , units_sold(n) , revenue(p*n)&#123; &#125;</div></pre></td></tr></table></figure>
<h4 id="访问控制与封装（隐藏）"><a href="#访问控制与封装（隐藏）" class="headerlink" title="访问控制与封装（隐藏）"></a>访问控制与封装（隐藏）</h4><p><code>class</code>和<code>struct</code>的区别：<code>class</code>的默认权限是<code>private</code>，<code>struct</code>的默认权限是<code>public</code>。</p>
<p><strong>友元（friend）</strong></p>
<p>类允许其他类或函数访问它的非公有成员。</p>
<p><strong>可变数据成员（mutable data member）</strong></p>
<p><code>const</code>成员函数可以改变一个可变成员的值，任何函数都可以改变它的值。</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><table>
<thead>
<tr>
<th style="text-align:center">容器类型</th>
<th style="text-align:center">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">双端队列。支持快速随机访问。头尾插入/删除很快</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双向链表。只支持双向顺序访问。在list中任何位置插入/删除速度很快。</td>
</tr>
<tr>
<td style="text-align:center">forward_list</td>
<td style="text-align:center">单向链表。只支持单向顺序访问。任何位置插入/删除速度很快。</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">固定大小的数组。支持快速随机访问。不能添加或删除</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">与vector相似的容器，专门用于保存字符。随机访问快。在尾部插入/删除快。</td>
</tr>
</tbody>
</table>
<p><code>string</code>和<code>vector</code>将元素保存在连续的内存空间内。</p>
<h3 id="容器库"><a href="#容器库" class="headerlink" title="容器库"></a>容器库</h3><h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><p>实际上，end是最后一个元素的后面，所以范围：[begin, end)</p>
<p>基于此的一些假定：</p>
<ul>
<li>如果<code>begin</code>和<code>end</code>相等，范围为空。</li>
<li>如果不等，则范围至少包括一个元素且为<code>begin</code>所指向的元素。</li>
<li>可以对<code>begin</code>递增若干次，使得<code>begin</code> == <code>end</code></li>
</ul>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>相同但是不同容量的时候，用<strong><code>assign</code></strong>。</p>
<p><code>seq.assign(b, e)</code>可以将<code>seq</code>中的元素替换成b和e所表示的范围中的元素。</p>
<p><strong>容器元素是拷贝</strong></p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p><code>string</code>的搜索操作：<code>find(args)</code>, <code>find_first_of(args)</code>, <code>find_last_not_of(args)</code></p>
<p>一个写法：<code>while( pos = name.find_first_of(numbers, pos) != string.npos)</code></p>
<p><code>find_first_of()</code>解决的是<strong>查找与给定字符串中任何一个字符匹配的位置</strong>。</p>
<h5 id="rfind-args-和-find-last-of-args-的区别："><a href="#rfind-args-和-find-last-of-args-的区别：" class="headerlink" title="rfind(args) 和 find_last_of(args) 的区别："></a><strong><code>rfind(args)</code> 和 <code>find_last_of(args)</code> 的区别：</strong></h5><p><code>rfind</code>找的是匹配的全部字符，<code>find_last_of()</code>是匹配任意一个字符。</p>
<h5 id="提取一句话中的数字"><a href="#提取一句话中的数字" class="headerlink" title="提取一句话中的数字"></a>提取一句话中的数字</h5><p>对于形如<code>pi = 3.14</code>的语句：</p>
<p><code>d = stod(s2.substr(s2.find_first_of(&quot;+-.0123456789&quot;)))</code></p>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p><code>适配器(adaptor)</code>是标准器中的一个通用概念。适配器有一些基本的要求，符合要求以后啥都可以。</p>
<h3 id="泛型算法-generic-algorithm"><a href="#泛型算法-generic-algorithm" class="headerlink" title="泛型算法(generic algorithm)"></a>泛型算法(generic algorithm)</h3><p>多数在<code>algorithm</code>中，少数在<code>numeric</code>中。这些算法不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<h5 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h5><p><code>find</code>和<code>accumulate</code>(位于<code>numeric</code>库中)。</p>
<p><code>int sum = accumulate(vec.begin(), vec.end*(), 0);</code>第三个参数的类型决定了函数中使用哪个加法运算符和返回值的类型。最好使用<code>cbegin()</code>和<code>cend()</code>。</p>
<p><code>equal</code>用来确定两个序列是否保存相同的值。<strong>假设第二个至少和第一个一样长</strong></p>
<h5 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h5><p><code>fill</code>接受一对迭代器表示范围，一个值用来赋值。</p>
<p><code>fill_n</code>从迭代器开始计数<code>n</code>个。<strong>这些都不能用来给空的写</strong>，除非使用<strong>插入迭代器(insert iterator)</strong>。</p>
<p><code>back_inserter</code>是定义在<code>iterator</code>的插入迭代器，接受一个指向容器的引用，返回一个与容器绑定的插入迭代器。通过给这个迭代器赋值的时候，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中。</p>
<p><code>copy</code>,<code>replace</code>,<code>replace_copy</code></p>
<h5 id="重排容器元素"><a href="#重排容器元素" class="headerlink" title="重排容器元素"></a>重排容器元素</h5><p><code>sort</code>函数。<code>stable_sort</code>函数可以维持相等元素的原有顺序。</p>
<p>利用<code>unique</code>标准库去重：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    sort(words.begin(), words.end());</div><div class="line">    <span class="comment">// unique重排输入范围，每个单词只出现一次</span></div><div class="line">    <span class="comment">// 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器。</span></div><div class="line">    <span class="keyword">auto</span> end_unique = unique(words.begin(), words.end());</div><div class="line">    <span class="comment">// 使用erase来去掉重复的元素。</span></div><div class="line">    words.erase(end_unique, words.end());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h5><p><strong>谓词(predicate)</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。一元谓词，二元谓词是针对参数的个数。</p>
<p><strong><code>lambda</code>表达式</strong>：</p>
<p><code>\[capture list\](parameter list) -&gt; return type { function body }</code></p>
<p><code>lambda</code>通过将局部变量包含在捕获列表中指出将会使用这些变量。只用<strong>局部非static变量</strong>。</p>
<p>通常是不能改变值的，但是可以在参数列表首加上<code>mutable</code>就可以了。</p>
<p>如果一个<code>lambda</code>体包含<code>return</code>之外的任何语句，编译器假定此<code>lambda</code>返回<code>void</code>。</p>
<p><code>[](int i) -&gt; int { if( i&lt;0 ) return -i; else return i; }</code></p>
<p><code>find_if</code>, <code>for_each</code>算法</p>
<p>隐式捕获：<code>[=]</code>表示值捕获，<code>[&amp;]</code>表示引用捕获。</p>
<h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a><code>bind</code>函数</h5><p>定义在<code>functional</code>中，可看作一个通用的函数适配器。它接受一个可调用对象，生成一个新的可调用对象来是一个原对象的参数列表。</p>
<p><code>auto newCallable = bind(callable, arg_list);</code></p>
<p>例如：<code>bind(check_size,  _1, sz);</code>使用<code>_1</code>表示第一个参数，然后<code>check_size</code>的第二个参数绑定到<code>sz</code>的值上。不过可能是<code>using std::placeholders::_1</code>。</p>
<p>引用的问题，可以用标准库的<code>ref</code>函数。</p>
<h5 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h5><p>接受一个容器，生成一个迭代器，能实现向给定容器插入元素。插入器有三种类型：<strong>back_inserter</strong>, <strong>front_inserter</strong>, <strong>inserter</strong>.</p>
<h5 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a><code>iostream</code>迭代器</h5><p><code>istream_iterator</code>读取输入流，<code>ostream_iterator</code>向一个输出流写数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>);</div><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;</div><div class="line"><span class="keyword">while</span> (in_iter != eof)</div><div class="line">    <span class="comment">// 返回的是旧值，*取的也是旧值。</span></div><div class="line">    vec.push_back(*in_iter++);</div></pre></td></tr></table></figure>
<p>可以使用算法操作流迭代器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in(<span class="built_in">cin</span>), eof;</div><div class="line"><span class="comment">// 输出从标准输入读取的值的和。</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p><code>ostream_iterator</code>还有更好用的功能，可以加一个值，每个值后面都输出一个。</p>
<h5 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h5><p>反向迭代器会反着处理。需要调用<code>reverse_iterator</code>的<code>base</code>成员函数来完成“掉头”的转换。</p>
<h4 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h4><p>五个迭代器类别（iterator category）</p>
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">输入迭代器</td>
<td style="text-align:center">只读，不写；单遍扫描，只能递增</td>
</tr>
<tr>
<td style="text-align:center">输出迭代器</td>
<td style="text-align:center">只写，不读；单遍扫描，只能递增</td>
</tr>
<tr>
<td style="text-align:center">前向迭代器</td>
<td style="text-align:center">可读写；多遍扫描，只能递增</td>
</tr>
<tr>
<td style="text-align:center">双向迭代器</td>
<td style="text-align:center">可读写；多遍扫描，可递增递减</td>
</tr>
<tr>
<td style="text-align:center">随机访问迭代器</td>
<td style="text-align:center">可读写；多遍扫描，支持全部迭代器计算</td>
</tr>
</tbody>
</table>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>标准库一共有8个关联容器，两大种：<code>set</code>和<code>map</code>。有<code>multi</code>前缀表示关键字可重复出现。有<code>unordered</code>表示是用哈希组织的。</p>
<p>对于有序类型，关键字类型必须定义元素比较的方法。</p>
<h4 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a><code>pair</code>类型</h4><p><code>pair</code>的数据类型是<code>public</code>的，两个成员分别命名为<code>first</code>和<code>second</code>。</p>
<p>几个类型别名：<code>key_type</code>, <code>mapped_type</code>, <code>value_type</code>。</p>
<p>解引用一个容器迭代器的时候，我们会得到一个类型为<code>value_type</code>的值的引用，对<code>map</code>而言，是<code>pair</code>类型。</p>
<p><code>set</code>和<code>map</code>的关键字都是<code>const</code>的。</p>
<p><code>insert</code>的返回值是一个<code>pair</code>，<code>pair.first</code>是指向具有给定关键字的元素，<code>second</code>成员是一个<code>bool</code>值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// map</span></div><div class="line">c[k] <span class="comment">// 返回关键字为k的元素，如果k不在c中，添加一个关键字为k的元素对其进行值初始化。</span></div><div class="line">c.at(k) <span class="comment">// 访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常。</span></div></pre></td></tr></table></figure>
<h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><p><code>c.find(k)</code>：返回一个迭代器，指向第一个关键字为<code>k</code>的元素。</p>
<p><code>c.count(k)</code>：返回关键字为<code>k</code>的元素的数量。</p>
<p><code>c.lower_bound(k)</code>：返回一个迭代器，指向第一个关键字不小于<code>k</code>的元素。</p>
<p><code>c.upper_bound(k)</code>：指向第一个关键字大于<code>k</code>的元素。</p>
<p><code>c.equal_range(k)</code>：返回一个迭代器<code>pair</code>，表示关键字等于<code>k</code>的元素的范围。若不存在，返回<code>c.end()</code></p>
<p>如果我们想知道一个元素是否在<code>map</code>中，而不想插入这个元素，用<code>find</code>更好。</p>
<h5 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h5><p>无序容器在存储上组织为一个桶，每个桶保存零个或多个元素。无序容器还提供了一组管理桶的函数。</p>
<h3 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h3><p>静态内存：局部<code>static</code>对象、类<code>static</code>数据成员以及定义在任何函数之外的变量。</p>
<p>栈内存：定义在函数内的非<code>static</code>对象。</p>
<p>堆/自由空间：动态分配的对象。</p>
<h4 id="动态内存的管理"><a href="#动态内存的管理" class="headerlink" title="动态内存的管理"></a>动态内存的管理</h4><p>通过一对<code>new</code>和<code>delete</code>操作。</p>
<p>很容易危险：1.  没有释放导致内存泄漏。2. 提前删除导致引用非法内存的指针。</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>新的标准库提供了两种<strong>智能指针（smart pointer）</strong></p>
<p><code>shared_ptr</code>, <code>unique_ptr</code>, <code>weak_ptr</code>.</p>
<h5 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a><code>shared_ptr</code>类</h5><p>智能指针也是模板，需要提供指针可以指向的类型。</p>
<p><code>shared_ptr</code>独有的操作：</p>
<h6 id="make-shared-lt-T-gt-args"><a href="#make-shared-lt-T-gt-args" class="headerlink" title="make_shared&lt;T&gt; (args)"></a><code>make_shared&lt;T&gt; (args)</code></h6><p><code>&lt;memory&gt;</code>头文件中。</p>
<p>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>，用<code>args</code>初始化的对象。</p>
<h6 id="拷贝与赋值"><a href="#拷贝与赋值" class="headerlink" title="拷贝与赋值"></a>拷贝与赋值</h6><p><code>shared_ptr</code>会记录有多少个其他的<code>shared_ptr</code>指向相同的对象，引用计数（reference count）。</p>
<p>当一个对象的最后一个<code>shared_ptr</code>被销毁时，<code>shared_ptr</code>会自动销毁此对象。通过调用析构函数来完成。</p>
<h6 id="new与delete"><a href="#new与delete" class="headerlink" title="new与delete"></a><code>new</code>与<code>delete</code></h6><p>默认情况下，动态分配的对象是默认初始化的。</p>
<p>如果分配失败，<code>new</code>会抛出<code>std::bad_alloc</code>错误。可以<code>new (nothrow) int</code>，此时分配失败会返回空指针。</p>
<p><code>delete</code>后需要重置指针值。</p>
<p><code>shared_ptr</code>接受指针参数的智能指针构造函数是<code>explicit</code>的，不能把一个内置指针隐式转为一个智能指针，必须使用直接初始化形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 (<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)); <span class="comment">// 正确</span></div></pre></td></tr></table></figure>
<p>一个危险的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int *x(new int(1024)); //危险：x是一个普通指针，不是智能指针</div><div class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">//合法，但内存会被释放。</span></div><div class="line"><span class="keyword">int</span> j = *x; <span class="comment">//未定义的，x是一个空指针。</span></div></pre></td></tr></table></figure>
<p>一旦把指针交给了智能指针，就由智能指针来负责了。</p>
<p>另一个危险的情况：<strong>永远不要用<code>get</code>初始化另一个智能指针或为另一个智能指针赋值，</strong>两者的计数都是1,所在程序块结束后，会销毁的。</p>
<h6 id="使用自己的释放操作"><a href="#使用自己的释放操作" class="headerlink" title="使用自己的释放操作"></a>使用自己的释放操作</h6><p>删除器（deleter）函数能够完成对<code>shared_ptr</code>中保存的指针进行释放的操作。在创建一个<code>shared_ptr</code>的时候，可以传递一个（可选的）指向删除器函数的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconncet(*p); &#125;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</div></pre></td></tr></table></figure>
<h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h5><p>某个时刻只能有一个<code>unique_ptr</code>指向一个给定对象，当它被销毁时，它所指向的对象也被销毁。没有<code>make_shared</code>类似的操作。<code>unique_ptr</code>不支持拷贝、赋值（p1赋值给p2）。</p>
<p>但是可以通过使用<code>release</code>或<code>reset</code>将指针的所有权从一个（非<code>const</code>）<code>unique_ptr</code>转移给另一个<code>unique</code>。</p>
<p>但是对于编译器知道返回的对象将要被销毁的时候，是可以拷贝的。</p>
<h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h5><p>一个弱指针，不控制所指向的对象的生存期。因为它指向的不一定可以用，所以需要调用<code>lock</code>来看一下。</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p><code>c++</code>语言定义了<code>new</code>表达式语法，可以分配并初始化一个对象数组。标准库包含一个名为<code>allocator</code>的类，允许我们将分配和初始化分离。</p>
<h5 id="new类"><a href="#new类" class="headerlink" title="new类"></a><code>new</code>类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()];</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</div><div class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;</div><div class="line"></div><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();<span class="comment">// 10个值初始化为0的int</span></div><div class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</div><div class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]();</div></pre></td></tr></table></figure>
<p>分配一个数组会得到一个与元素的类型的指针。</p>
<p><code>shared_ptr</code>不支持直接管理动态数组，必须要提供自己定义的删除器。</p>
<h5 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a><code>allocator</code>类</h5><p>在头文件<code>memory</code>中，它帮助我们将内存分配和对象构造分离开。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p>
<p><code>allocator</code>分配的内存是未构造的，我们按需要在此内存中构造对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> q = p; <span class="comment">// q指向最后构造元素之后的位置</span></div><div class="line">alloc.construct(q++);</div><div class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">'c'</span>);</div><div class="line">alloc.construct(q++, <span class="string">"hi"</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (q != p)</div><div class="line">    alloc.destory(--q);</div></pre></td></tr></table></figure>
<p>还可以拷贝和填充未初始化内存的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">uninitialized_copy(b, e, b2); <span class="comment">// 把迭代器b到e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中</span></div><div class="line">uninitialized_fill(b, e, t);</div></pre></td></tr></table></figure>
<h3 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h3><p>一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。</p>
<h4 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h4><h5 id="拷贝构造函数（copy-constructor）"><a href="#拷贝构造函数（copy-constructor）" class="headerlink" title="拷贝构造函数（copy constructor）"></a>拷贝构造函数（copy constructor）</h5><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则是拷贝构造函数。</p>
<p>直接初始化实际上是要求编译器使用普通的函数匹配来选择我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时， 我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p>
<p>拷贝初始化的发生：</p>
<ol>
<li>使用=定义变量时</li>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号初始化一个数组中的元素或一个聚合类中的成员。</li>
</ol>
<p>某些标准库容器在<code>insert</code>和<code>push</code>时也会对元素进行拷贝初始化。</p>
<p><strong>拷贝构造函数自己的参数必须是引用类型</strong></p>
<h5 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h5><p><strong>重载运算符（overloaded operator）</strong></p>
<p>本质是函数，其名字由<code>operator</code>关键字后接表示要定义的运算符的符号组成。</p>
<h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>一个波浪号接类名构成。</p>
<p>析构部分是隐式的，智能指针是类类型，所以也有析构函数。</p>
<p><strong>调用析构的时机</strong></p>
<ul>
<li>变量在离开作用域时</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>动态分配的对象，当对指向它的指针引用<code>delete</code>运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p>核心思想：数据抽象、继承和动态绑定。</p>
<h5 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h5><p>通过继承联系在一起的类构成一种层次关系。基类和派生类。</p>
<p>对于某些基类希望它的派生类各自定义适合自身的版本，就可以声明成<strong>虚函数（virtual function）</strong>。</p>
<p>派生类必须通过使用类派生列表明确指出是从哪些基类继承而来。</p>
<h5 id="动态绑定（dynamic-binding）"><a href="#动态绑定（dynamic-binding）" class="headerlink" title="动态绑定（dynamic binding）"></a>动态绑定（dynamic binding）</h5><p>基类通常应该定义一个<strong>虚析构函数</strong>。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。</p>
<p>基类希望它的派生类有权访问该成员，同时禁止其他用户访问，用<code>protected</code>来说明。</p>
<p>派生类经常但不总是override它继承的虚函数。</p>
<p>可以把基类的指针或引用绑定到派生类对象中的基类的部分上，这种转换通常称为派生类到基类的类型转换。</p>
<p><strong>静态成员</strong>在整个继承体系中只存在该成员的唯一定义。</p>
<h6 id="存在继承关系的类型之间的转换规则"><a href="#存在继承关系的类型之间的转换规则" class="headerlink" title="存在继承关系的类型之间的转换规则"></a>存在继承关系的类型之间的转换规则</h6><ul>
<li>从派生类到基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样，派生类到基类的类型转换也会由于权限受限而变得不可行。</li>
</ul>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>对虚函数的调用可能在运行时才被解析</p>
<p>动态绑定只有当我们通过指针或引用调用虚函数时才会发生。</p>
<p><strong>多态性</strong></p>
<p>多种形式。有继承关系的多个类型称为多态类型，我们可以使用这些类型而无须在意他们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。</p>
<p><code>override</code>用来标记对虚函数的覆盖。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li>C++中，名字查找发生在类型匹配前。</li>
<li>内联说明只是向编译器发送一个请求，编译器可以忽略。</li>
<li>在类内部的函数是隐式的<code>inline</code>函数。</li>
<li>没什么特别好的理由，就用<code>vector</code></li>
<li>除了<code>array</code>之外，<code>swap</code>不对任何元素进行拷贝、删除或插入操作，可以保证在常数时间内完成。</li>
<li>泛型算法不会执行容器的操作，所以不会直接添加或者删除元素。</li>
<li>在新版本的C++中， 可以用花括号来创建<code>pair</code>类型。</li>
<li><code>-&gt;</code>相当于<code>*</code>后<code>.</code>。</li>
<li>如果把<code>shared_ptr</code>存放于一个容器，而后不再需要全部元素，只使用其中一部分，要记得用<code>erase</code>删除不再需要的那些元素。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/coding/" rel="tag"># coding</a>
          
            <a href="/tags/cpp/" rel="tag"># cpp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/02/UTF-8 with BOM/" rel="next" title="UTF-8 with BOM">
                <i class="fa fa-chevron-left"></i> UTF-8 with BOM
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/25/A c++ compile time error/" rel="prev" title="A c++ compile time error.">
                A c++ compile time error. <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">松鹅</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/dreamgod2016" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:dreamgod007@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">1.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取中间值"><span class="nav-number">1.1.</span> <span class="nav-text">取中间值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂的数组声明"><span class="nav-number">2.1.</span> <span class="nav-text">复杂的数组声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#begin函数"><span class="nav-number">2.2.</span> <span class="nav-text">begin函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较字符串"><span class="nav-number">2.3.</span> <span class="nav-text">比较字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内联函数"><span class="nav-number">3.1.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数指针"><span class="nav-number">3.2.</span> <span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#debug技巧"><span class="nav-number">3.3.</span> <span class="nav-text">debug技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">4.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const成员函数"><span class="nav-number">4.1.</span> <span class="nav-text">const成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">4.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问控制与封装（隐藏）"><span class="nav-number">4.3.</span> <span class="nav-text">访问控制与封装（隐藏）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序容器"><span class="nav-number">5.</span> <span class="nav-text">顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">5.1.</span> <span class="nav-text">简介</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器库"><span class="nav-number">6.</span> <span class="nav-text">容器库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代器-1"><span class="nav-number">6.0.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#赋值"><span class="nav-number">6.0.2.</span> <span class="nav-text">赋值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string"><span class="nav-number">6.1.</span> <span class="nav-text">string</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#rfind-args-和-find-last-of-args-的区别："><span class="nav-number">6.1.1.</span> <span class="nav-text">rfind(args) 和 find_last_of(args) 的区别：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提取一句话中的数字"><span class="nav-number">6.1.2.</span> <span class="nav-text">提取一句话中的数字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器适配器"><span class="nav-number">6.2.</span> <span class="nav-text">容器适配器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型算法-generic-algorithm"><span class="nav-number">7.</span> <span class="nav-text">泛型算法(generic algorithm)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#只读算法"><span class="nav-number">7.0.1.</span> <span class="nav-text">只读算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写容器元素的算法"><span class="nav-number">7.0.2.</span> <span class="nav-text">写容器元素的算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重排容器元素"><span class="nav-number">7.0.3.</span> <span class="nav-text">重排容器元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向算法传递函数"><span class="nav-number">7.0.4.</span> <span class="nav-text">向算法传递函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bind函数"><span class="nav-number">7.0.5.</span> <span class="nav-text">bind函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入迭代器"><span class="nav-number">7.0.6.</span> <span class="nav-text">插入迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iostream迭代器"><span class="nav-number">7.0.7.</span> <span class="nav-text">iostream迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反向迭代器"><span class="nav-number">7.0.8.</span> <span class="nav-text">反向迭代器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型算法结构"><span class="nav-number">7.1.</span> <span class="nav-text">泛型算法结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联容器"><span class="nav-number">8.</span> <span class="nav-text">关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pair类型"><span class="nav-number">8.1.</span> <span class="nav-text">pair类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#访问元素"><span class="nav-number">8.1.1.</span> <span class="nav-text">访问元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无序容器"><span class="nav-number">8.1.2.</span> <span class="nav-text">无序容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态内存"><span class="nav-number">9.</span> <span class="nav-text">动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态内存的管理"><span class="nav-number">9.1.</span> <span class="nav-text">动态内存的管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能指针"><span class="nav-number">9.2.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#shared-ptr类"><span class="nav-number">9.2.1.</span> <span class="nav-text">shared_ptr类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#make-shared-lt-T-gt-args"><span class="nav-number">9.2.1.1.</span> <span class="nav-text">make_shared<T> (args)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#拷贝与赋值"><span class="nav-number">9.2.1.2.</span> <span class="nav-text">拷贝与赋值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#new与delete"><span class="nav-number">9.2.1.3.</span> <span class="nav-text">new与delete</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用自己的释放操作"><span class="nav-number">9.2.1.4.</span> <span class="nav-text">使用自己的释放操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unique-ptr"><span class="nav-number">9.2.2.</span> <span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#weak-ptr"><span class="nav-number">9.2.3.</span> <span class="nav-text">weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态数组"><span class="nav-number">9.3.</span> <span class="nav-text">动态数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#new类"><span class="nav-number">9.3.1.</span> <span class="nav-text">new类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#allocator类"><span class="nav-number">9.3.2.</span> <span class="nav-text">allocator类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝控制"><span class="nav-number">10.</span> <span class="nav-text">拷贝控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝、赋值与销毁"><span class="nav-number">10.1.</span> <span class="nav-text">拷贝、赋值与销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拷贝构造函数（copy-constructor）"><span class="nav-number">10.1.1.</span> <span class="nav-text">拷贝构造函数（copy constructor）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拷贝赋值运算符"><span class="nav-number">10.1.2.</span> <span class="nav-text">拷贝赋值运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#析构函数"><span class="nav-number">10.1.3.</span> <span class="nav-text">析构函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象程序设计"><span class="nav-number">11.</span> <span class="nav-text">面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#继承（inheritance）"><span class="nav-number">11.0.1.</span> <span class="nav-text">继承（inheritance）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态绑定（dynamic-binding）"><span class="nav-number">11.0.2.</span> <span class="nav-text">动态绑定（dynamic binding）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#存在继承关系的类型之间的转换规则"><span class="nav-number">11.0.2.1.</span> <span class="nav-text">存在继承关系的类型之间的转换规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数"><span class="nav-number">11.1.</span> <span class="nav-text">虚函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tips"><span class="nav-number">12.</span> <span class="nav-text">Tips</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">松鹅</span>

  
</div>
<div style="display:none;">
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1264920242'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1264920242' type='text/javascript'%3E%3C/script%3E"));</script>
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>


-->
        







  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1264920242&web_id=1264920242" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
